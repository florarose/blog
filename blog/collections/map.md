# map
1.8 为主

# 问题罗列
1. 采用何种数据结构，优缺点，包括时间复杂度;
2. hash值得计算、存储结构、数据插入方式、扩容机制
3. 哈希冲突定义、解决哈希冲突的方法及其优缺点
4. 为什么默认初始化桶数组大小为16 ？
5. 为何是2的倍数 ？
6. 如何保证容量始终为2的整数平方倍？
7. 为什么每次1、2、4、8、16移动？
8. 为什么一共移动31位？
9. 尾插法和头插法的区别
10. 负载因子: loadFactor：，默认为 0.75。为什么是 0.75
11. 存储结构，链表转红黑树的时机、条件
12. 
# 基本介绍
map 以 key-value 形式存储数据，最外层使用数组,根据key的 （hash值 & 数组的长度-1）定位在数组中的下标，如果没有产生哈希冲突，创建一个新的节点，放入对应位置即可；
如果产生哈希冲突，采用链地址法，把新节点放入链表的尾部，如果链表的长度大于 8 并且 数组的长度大于等于 64,转化为红黑树，如果只是大于8,数组长度小于64，只是扩容。
# 数据结构

JDK1.8 数据结构采用 数组+链表+红黑树,数组与链表节点使用Node类实现,红黑树使用TreeNode类实现;

# 基本问题：
## 哈希值计算
(h = key.hashCode()) ^ (h >>> 16) <br/>
哈希值 =  key 的hash  &  key的hash的16次位运算（哈希值 =  key 的哈希值 与 key 的哈希值的16次位运算）

## 数据插入方式
尾插法
扩容后的位置：原位置 或者 原位置+ 旧容量
插入数据：扩容前插入，在转移数据时统一计算位置
(顺便说下之前1.7 用的是头插法，介绍头插和尾插的区别)

## 扩容
## 哈希冲突

hashMap 采用链地址法解决哈希冲突。
将冲突位置的元素构造成链表。在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上。

拉链法的优点：
 处理冲突的方式简单，且无堆集现象，非同义词绝不会发生冲突，因此平均查找长度较短；
 由于拉链法中各链表上的结点空间是动态申请的，所以它更适合造表前无法确定表长的情况；
 删除结点操作易于实现，只要简单地删除链表上的相应的结点即可。
拉链法的缺点：
   需要额外的存储空间。
## 为什么默认初始化桶数组大小为16 ？
太大，浪费空间，影响效率；太小，容易发生扩容影响性能。 在使用时，预估元素的个数能够有效的提高hashmap的性能i。
因为16对应的2进制数为1111； 如此数组的下标就等同于Hashcode后四位的值，只要输入的hash值本身分布均匀，那么数组的下标必然均匀，hashmap默认长度为16的目的就是为了解决hash碰撞的机率。
如果是14，二进制位1110，最后一位为0，导致散列函数计算后为0001,0101等永远不会出现，则位置就不能存放元素，增加了 散列碰撞的机率。
2的幂次方拥有更低的碰撞机率和更高的查询速率。

## 为何是2的倍数 ？
HashMap 中通过h&(length-1) 的方法代替取模法。取模的消耗较大 ，对于我们来说，适合10进制运算,也就是取模运算。而计算机适合二进制运算,在实现位运算的时候是很高效的,因此使用与运算。

length 为2的整数次幂的话，h&(length-1)运算即相当于对length取模，也就是h%length，这样即保证了散列的均匀，减少了冲突，也提升了效率;
length 为2的整数次幂的话，length-1为奇数，奇数的最后一位是1，这样的结果是h&(length-1)的最后一位可能 是0，也可能是1，都取决于h的值，与后的结果就有了奇偶两种可能，这样也可以保证散列的均匀性;
如果length为奇数，length-1 必定为偶数，最后一位是0;h&(length-1)的最后一位也必定是0，即是偶数。如次一来任何hash值都只会被散列到数组的偶数下标位置上，这就浪费了近一半的空间。
因此，length取2的整数次幂，是为了使用不同hash值发生碰撞的概率较小，这样就可以使元素在哈希表中均匀地散列。

# 备注
 版本 | 初始化方式 | hash值得计算 | 存放数据 | 插入数据的方式
---|--- |--- |--- |---
JDK 1.8 | 初始化方式集成在扩容函数resize()方法中 | hashCode()+ 扰动处理(2次=1次位运算+ 1次异或运算) |  数组+链表+红黑树| 尾插法（直接插入到链表尾部/红黑树）
